# Defines the address spaces/blocks for each addressible device
MEMORY {
    ZEROPAGE:   start = $0000, size = $0100, file = "", define = yes;
    RAM:        start = $0200, size = $3500, file = "", define = yes;
    VRAM:       start = $3700, size = $0900, file = "";
    FIRMWARE:   start = $4000, size = $3000, file = "build/memory/%O_fw.bin";
    # This memory area is not to be flashed, just for use with the py65 simulator
    # to simulate controller button inputs.
    IO:         start = $7000, size = $1000, file = "build/memory/%O_io.bin";
    ROM:        start = $8000, size = $8000, file = "build/memory/%O_rom.bin";
}

SEGMENTS {
    ZEROPAGE:           load = ZEROPAGE, type = zp;

    # Block Starting Segment, stores all uninitialized global variables
    # Why this memory segment exists: https://stackoverflow.com/a/9535579/3339274
    BSS:                load = RAM, type = bss, define = yes, optional = yes;

    # VRAM memory segments
    PMF:                load = VRAM, type = rw, start = $3700;
    PMB:                load = VRAM, type = rw, start = $3900;
    NTBL:               load = VRAM, type = rw, start = $3b00;
    OBM:                load = VRAM, type = rw, start = $3f00;

    FPGA_FW_HEADER:     load = FIRMWARE, type = ro, start = $4000; # Code version identifier
    STARTUP:            load = FIRMWARE, type = ro;
    ONCE:               load = FIRMWARE, type = ro, optional = yes;
    FIRMWARE_CODE:      load = FIRMWARE, type = ro;

    # Game controller button IO segment
    IO:                 load = IO, type = rw, start = $7000;

    # C code segments
    ROM_FW_HEADER:      load = ROM, type = ro, start = $8100; # Code version idenfifier
    ROM_GAME_HEADER:    load = ROM, type = ro; # Code version idenfifier
    # Hard-coded locations for the three game code functions ensures
    # interoperability between all games, which may have differently sized funcs
    RESET:              load = ROM, type = ro, start = $9000;
    DO_LOGIC:           load = ROM, type = ro, start = $a000;
    FILL_VRAM:          load = ROM, type = ro, start = $b000;
    DATA:               load = ROM, type = rw, define = yes, run = RAM, optional = yes;
    CODE:               load = ROM, type = ro, start = $c000, optional = yes;
    VECTORS:            load = ROM, type = overwrite, start = $fffa;
}

# https://cc65.github.io/doc/customizing.html#s2
FEATURES {
    CONDES:    segment = STARTUP,
               type    = constructor,
               label   = __CONSTRUCTOR_TABLE__,
               count   = __CONSTRUCTOR_COUNT__;
    CONDES:    segment = STARTUP,
               type    = destructor,
               label   = __DESTRUCTOR_TABLE__,
               count   = __DESTRUCTOR_COUNT__;
}

SYMBOLS {
    # Define the stack size for the application
    __STACKSIZE__:  value = $0200, type = weak;
}
